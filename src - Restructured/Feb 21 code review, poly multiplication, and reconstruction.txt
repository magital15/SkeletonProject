Tuesday evening 2/21
~Tali Magidson

Earlier today, Cody and I met with Ben to discuss header file and c++ struct organization.

CONTENTS of this file:
Code review of https://github.com/CodyMoody/Skeleton-Project
Half-finished code for brute force polynomial multiplication and for serial coefficient reconstruction. The latter is ready to be tested with a Poly. This is the sanity check that Dr. Storti asked for >> applicable once we combine Cody's code with mine in one repository.


minusMult doesn't mod by anything yet >> research negative number modular arithmetic rules
In addPolys, cudaMemcpy from device to host should happen AFTER all kernel calls complete
during testing in main.cpp, booleans can just be accessed as if(theThingIsHappening)

Question to chew on - all arithmetic functions are currently called by a Poly but then are parallelized by PolyDense. Seems like there are two distinct use cases here:
	1) We want an entire poly to be multiplied by a scalar or monomial
	We want two entire poly's to be added / subtracted / multiplied / divided
		In this case, it makes sense to pass in the entire poly and parallelize by double index coordinate - THE KERNEL CODE BELOW IS STILL WRONG
	2) We want to do something to a single PolDense in a Poly (probably a sub routine of performing division).
		In this case, we pass in the entire poly and a polDense index and apply the change only to that row. Are these operations worth calling kernels for?? Potentially these will be sequential __device__ functions.
	
Multiplication by a monomial has to increase the length of all PolyDense members in a Poly unless there is some leeway length not yet being used - begin with a length buffer.



CPU code for multiplication

%%%%%%%%%%%% in main.cpp %%%%%%%%%%%%%%%%%%%%%%%
//  a * b = f	--TESTING--

	Poly c;
	int newLength = a.members[0].length + b.members[0].length;
	for (int i = 0; i < NUMPRIMES + 1; i++)
	{
		c.members[i].coeffs = (int*)calloc(newLength, sizeof(int));
		c.members[i].length = newLength;
	}

	multPolys(a, b, c, primeArray);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
void multPolys(Poly a, Poly b, Poly c, int* primeArray) {
	// BRUTE FORCE COLUMN MULTIPLICATION
	// multiply a by every monomial in b, add these results to the required row in c
	
	// perhaps unnecessary middle step of storing the monomial multiplication >> temp results could directly be saved into output Poly
	
	Poly temp;
	int newLength = c.members[0].length;
	for (int i = 0; i < NUMPRIMES + 1; i++)
	{
		c.members[i].coeffs = (int*)calloc(newLength, sizeof(int));
		c.members[i].length = newLength;
	}
	
	// NEED TO PARALLELIZE THIS BY MONOMIAL, but be careful with numerous threads writing to output Poly
	
	for(int i = 0; i < b.members[0].length; i++) {
		multMonomialPoly(a, b, temp, primeArray, monomialIndex);
		addPolys(c, temp, c, primeArray);
		
		for (int i = 0; i < NUMPRIMES + 1; i++)
		{
			memset(c.members[i].coeffs, 0, c.members[i].length*sizeof(int);
		}
	}
}

%%%%%%%%%%%%% Write launcher function and index kernel call by two indexes %%%%%%%%%%%%

__global__

void monomialMultMods(int* d_out, int* d_in, int monomialPower, int scalar, int mod)

{
	const int i = blockIdx.x*blockDim.x + threadIdx.x;

	const float x = d_in[i];
	
	// shift over AND scale simultaneoustly. As a precondition, there is enough space in d_out to facilitate this index shift.
	d_out[i + monomialPower] = getRemainder(x*scalar, mod);

}

*************************************************************************************

CPU code for reconstructing original poly, modified from Tali's previous version

%%%%%%%%%%%% in main.cpp %%%%%%%%%%%%%%%%%%%%%%%

int reconstruct(Poly a, int *primeArray) {

	// assuming that the array to be reconstructed is the same length as all other PolyDense arrays in Poly... length is a local variable in PolyDense so that it doesn't have to be passed in to every method by Poly, however we must then be careful to keep it carefully updated
	
	// NEED TO PARALLELIZE THIS BY COEFFICIENT
	
	for(int i = 0; i < a.members[0].length; i++) {
		a.members[0].coeff[i] = reconstruct(a, i, primeArray);
	}
}

int reconstruct(Poly a, int col, int *primeArray) {
	
	int nextMember = 1;
	int nextPrime = 0;
	
	int a1 = a.members[nextMember++].coeff[col];

	int a2 = a.members[nextMember].coeff[col];

	int p1 = primeArray[nextPrime++];

	int p2 = primeArray[nextPrime];

	int a12 = 0;

	int prevAnswer = -1;

	

	while (nextPrime < NUMPRIMES && a12 != prevAnswer) {
		
		// only enter this on iterations beyond the first one
		if (nextPrime != 1) {

			a1 = a12;

			a2 = a.members[nextMember].coeff[col];

			p1 = p1*p2;

			p2 = primeArray[nextPrime];

		}



		int2 multiplicativeInverses = modInverse(p1, p2);

		int k1modp2 = multiplicativeInverses.x;

		int k2modp1 = multiplicativeInverses.y;



		prevAnswer = a12;

		a12 = (a2*k1modp2*p1 + a1*k2modp1*p2) % (p1*p2);

		// printf("clue %d gives the number %d \n \n", counter, a12);

		nextMember++;
		nextPrime++;

	}



	return a12;

}
















